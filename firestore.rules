rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read and write their own user document
    match /users/{userId} {
      // Allow reading own user doc
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Allow creating own user doc on first login
      allow create: if request.auth != null && request.resource.data.id == request.auth.uid;
      
      // Allow updating own user doc
      allow update: if request.auth != null && request.auth.uid == userId;
      
      // Never allow deletes
      allow delete: if false;
    }
    
    // Family documents - readable by all authenticated family members
    match /family/{document=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com', 
        'kwakhomdeni@gmail.com',
        'tina@salatiso.com',
        'visasande@gmail.com',
        'mdenivisa@gmail.com',
        'sazisimdeni@gmail.com',
        'milandep.mdeni@gmail.com',
        'milamdeni@gmail.com',
        'azoramdeni@gmail.com',
        'mdeninotembac@gmail.com'
      ];
    }
    
    // Business documents - readable by all authenticated family members
    match /business/{document=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com',
        'kwakhomdeni@gmail.com', 
        'tina@salatiso.com',
        'mdenit21@gmail.com',
        'visasande@gmail.com',
        'mdenivisa@gmail.com',
        'sazisimdeni@gmail.com',
        'milandep.mdeni@gmail.com',
        'milamdeni@gmail.com',
        'azoramdeni@gmail.com',
        'mdeninotembac@gmail.com'
      ];
    }
    
    // Projects collection - readable by all authenticated family members
    match /projects/{document=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com',
        'kwakhomdeni@gmail.com',
        'tina@salatiso.com',
        'mdenit21@gmail.com', 
        'visasande@gmail.com',
        'mdenivisa@gmail.com',
        'sazisimdeni@gmail.com',
        'milandep.mdeni@gmail.com',
        'milamdeni@gmail.com',
        'azoramdeni@gmail.com',
        'mdeninotembac@gmail.com'
      ];
    }
    
    // Documents collection - readable by all authenticated family members
    match /documents/{document=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com',
        'kwakhomdeni@gmail.com',
        'tina@salatiso.com',
        'mdenit21@gmail.com',
        'visasande@gmail.com', 
        'mdenivisa@gmail.com',
        'sazisimdeni@gmail.com',
        'milandep.mdeni@gmail.com',
        'milamdeni@gmail.com',
        'azoramdeni@gmail.com',
        'mdeninotembac@gmail.com'
      ];
    }
    
    // Phase 5: Analytics - Family members can read, authenticated users can write
    match /analytics/{analyticsId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null;
      allow delete: if false; // Never delete analytics
    }
    
    // Phase 5: Badges - Users can read, system awards
    match /badges/{badgeId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null;
      allow delete: if false; // Never delete badges
    }
    
    // Phase 5: Consents - Users control their own consents
    match /consents/{consentId} {
      allow read, write: if request.auth != null && 
                           resource.data.userId == request.auth.uid;
    }
    
    // Phase 5: Video Call Rooms - Family members can create and join
    match /video_rooms/{roomId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
                             resource.data.creatorId == request.auth.uid;
    }
    
    // Contacts collection - Users can manage their own contacts
    match /contacts/{contactId} {
      allow read: if request.auth != null && (
        resource.data.addedBy == request.auth.uid ||
        resource.data.userId == request.auth.uid
      );
      allow create: if request.auth != null && (
        request.resource.data.addedBy == request.auth.uid ||
        request.resource.data.userId == request.auth.uid
      );
      allow update: if request.auth != null && (
        resource.data.addedBy == request.auth.uid ||
        resource.data.userId == request.auth.uid
      );
      allow delete: if request.auth != null && (
        resource.data.addedBy == request.auth.uid ||
        resource.data.userId == request.auth.uid
      );
    }
    
    // User-specific contacts - Allow nested reads
    match /users/{userId}/contacts/{contactId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId && 
                       request.resource.data.addedBy == request.auth.uid;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Activity collection - Users can read their own activities
    match /users/{userId}/activity/{activityId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow delete: if false;
    }

    // Calendar Events collection - Users can manage their own calendar events
    match /calendarEvents/{eventId} {
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        request.auth.uid in resource.data.attendees
      );
      allow create: if request.auth != null && 
                       request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && 
                       resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && 
                       resource.data.userId == request.auth.uid;
    }
    
    // Ecosystem activity - All authenticated can read
    match /ecosystemActivity/{activityId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow delete: if false;
    }
    
    // Presence collection - Users can manage their own presence, others can read
    match /presence/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // User settings collection - Users can only access their own settings
    match /userSettings/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // ========================================================================
    // CALENDAR EVENTS COLLECTION - SPRINT 3.1 Enhanced Rules
    // ========================================================================
    
    // Events collection - Role-based access control with context awareness
    match /events/{eventId} {
      // Helper: Check if user is organizer
      function isOrganizer() {
        return resource.data.organizer == request.auth.uid;
      }
      
      // Helper: Get user's role in event
      function getUserRole() {
        return resource.data.roles.filter(r, r.userId == request.auth.uid);
      }
      
      // Helper: Check if user has specific permission
      function hasPermission(permission) {
        let userRoles = getUserRole();
        return userRoles.size() > 0 && permission in userRoles[0].permissions;
      }
      
      // Helper: Check if user can view based on visibility
      function canView() {
        return request.auth != null && 
               (isOrganizer() || 
                request.auth.uid in resource.data.roles.map(r, r.userId) ||
                request.auth.uid in resource.data.visibility);
      }
      
      // READ: User can read if organizer, has role, or in visibility list
      allow read: if canView();
      
      // CREATE: Authenticated users can create with themselves as organizer
      allow create: if request.auth != null &&
                       request.resource.data.organizer == request.auth.uid &&
                       request.resource.data.status == 'planned' &&
                       request.resource.data.type in ['activity', 'incident'];
      
      // UPDATE: Organizer or those with edit permission can update
      allow update: if request.auth != null && 
                       (isOrganizer() || hasPermission('edit'));
      
      // DELETE (Archive): Only organizer can archive events
      allow delete: if request.auth != null && 
                       isOrganizer();
      
      // Subcollections
      match /roles/{roleId} {
        allow read: if request.auth != null && 
                       get(/databases/$(database)/documents/events/$(eventId)).data.organizer == request.auth.uid;
        allow write: if request.auth != null && 
                        get(/databases/$(database)/documents/events/$(eventId)).data.organizer == request.auth.uid;
      }
      
      match /assistanceRequests/{requestId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null &&
                        get(/databases/$(database)/documents/events/$(eventId)).data.organizer == request.auth.uid;
      }
      
      match /polls/{pollId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null &&
                        (get(/databases/$(database)/documents/events/$(eventId)).data.organizer == request.auth.uid ||
                         get(/databases/$(database)/documents/events/$(eventId)).data.roles.filter(r, r.userId == request.auth.uid && 'edit' in r.permissions).size() > 0);
      }
    }
    
    // Assistance requests collection - Top-level for querying
    match /assistanceRequests/{requestId} {
      // READ: Participants and requesters can read
      allow read: if request.auth != null &&
                     (request.auth.uid == resource.data.requestedBy ||
                      request.auth.uid in resource.data.targetAudience);
      
      // CREATE: Users can create assistance requests for their events
      allow create: if request.auth != null &&
                       request.resource.data.requestedBy == request.auth.uid;
      
      // UPDATE: Requester can update status
      allow update: if request.auth != null &&
                       (resource.data.requestedBy == request.auth.uid ||
                        request.auth.uid in resource.data.targetAudience);
      
      // DELETE: Never allow deletion
      allow delete: if false;
    }
    
    // Audit logs collection
    match /auditLogs/{auditId} {
      // READ: Users can read their own audit logs
      allow read: if request.auth != null &&
                     resource.data.userId == request.auth.uid;
      
      // WRITE: Cloud function only - no direct writes
      allow write: if false;
    }
    
    // User sync settings
    match /userSyncSettings/{userId} {
      // READ: Users can read their own settings
      allow read: if request.auth != null &&
                     request.auth.uid == userId;
      
      // WRITE: Users can update their own settings
      allow write: if request.auth != null &&
                      request.auth.uid == userId;
    }
    
    // Sync logs collection
    match /syncLogs/{logId} {
      // READ: Users can read their own sync logs
      allow read: if request.auth != null &&
                     resource.data.userId == request.auth.uid;
      
      // WRITE: Cloud function only
      allow write: if false;
    }
    
    // ========================================================================
    // PHASE 2: POLLING & VOTING SYSTEM
    // ========================================================================
    
    function isPollParticipant(pollId) {
      let poll = get(/databases/$(database)/documents/polls/$(pollId)).data;
      return request.auth.uid in poll.participantIds;
    }
    
    function isPollCreator(pollId) {
      let poll = get(/databases/$(database)/documents/polls/$(pollId)).data;
      return request.auth.uid == poll.createdBy;
    }
    
    function canCreatePoll() {
      return request.auth != null;
    }
    
    function canVote(pollId) {
      let poll = get(/databases/$(database)/documents/polls/$(pollId)).data;
      return request.auth != null 
        && poll.status == 'open'
        && request.auth.uid in poll.participantIds
        && request.time < poll.deadline;
    }
    
    function canClosePoll(pollId) {
      return request.auth != null && isPollCreator(pollId);
    }
    
    function canManagePoll(pollId) {
      return request.auth != null && isPollCreator(pollId);
    }
    
    // Polls collection
    match /polls/{pollId} {
      // CREATE: Authenticated users
      allow create: if canCreatePoll()
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.status in ['draft', 'open']
        && request.resource.data.type in ['single_choice', 'multiple_choice', 'ranking']
        && request.resource.data.options.size() > 1
        && request.resource.data.deadline > request.time;
      
      // READ: Poll participants and creator
      allow read: if request.auth != null 
        && (isPollParticipant(pollId) || isPollCreator(pollId));
      
      // UPDATE: Poll creator only
      allow update: if canManagePoll(pollId)
        && (request.resource.data.status == 'draft'
          || (request.resource.data.status == 'open' && resource.data.status == 'open'));
      
      // DELETE: Creator only, if not yet started
      allow delete: if canManagePoll(pollId) && resource.data.status == 'draft';
      
      // Votes subcollection
      match /votes/{voteId} {
        // CREATE: Participants can submit votes
        allow create: if canVote(pollId)
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.pollId == pollId
          && request.resource.data.timestamp == request.time
          && request.resource.data.status == 'submitted';
        
        // READ: Voter themselves, poll creator, or if results are public
        allow read: if request.auth != null 
          && (request.auth.uid == resource.data.userId
            || request.auth.uid == get(/databases/$(database)/documents/polls/$(pollId)).data.createdBy
            || (get(/databases/$(database)/documents/polls/$(pollId)).data.config.showVoterNames == true));
        
        // UPDATE: Voter can change vote if allowed and poll still open
        allow update: if request.auth != null
          && request.auth.uid == resource.data.userId
          && get(/databases/$(database)/documents/polls/$(pollId)).data.config.allowChangeVote == true
          && get(/databases/$(database)/documents/polls/$(pollId)).data.status == 'open'
          && request.time < get(/databases/$(database)/documents/polls/$(pollId)).data.deadline;
        
        // DELETE: Voter can withdraw if allowed
        allow delete: if request.auth != null
          && request.auth.uid == resource.data.userId
          && get(/databases/$(database)/documents/polls/$(pollId)).data.config.allowWithdrawVote == true;
      }
    }
    
    // Poll results collection (server-write only)
    match /poll_results/{pollId} {
      // READ: Authenticated participants
      allow read: if request.auth != null;
      
      // WRITE: Server-side only
      allow write: if false;
    }
    
    // ========================================================================
    // PHASE 3: ESCALATION WORKFLOWS & INCIDENT DASHBOARD
    // ========================================================================
    
    // Escalation event helpers
    function isEscalationCreator(escalationId) {
      return request.auth != null && 
             request.auth.uid == get(/databases/$(database)/documents/escalations/$(escalationId)).data.createdBy;
    }
    
    function isCurrentOwner(escalationId) {
      return request.auth != null && 
             request.auth.uid == get(/databases/$(database)/documents/escalations/$(escalationId)).data.currentOwner;
    }
    
    function isAssignedResponder(escalationId) {
      let escalation = get(/databases/$(database)/documents/escalations/$(escalationId)).data;
      let assignments = escalation.responders;
      return request.auth != null && 
             assignments.size() > 0 && 
             assignments.any(r, r.userId == request.auth.uid);
    }
    
    function canEscalateIncident(escalationId) {
      let escalation = get(/databases/$(database)/documents/escalations/$(escalationId)).data;
      return request.auth != null && 
             (isCurrentOwner(escalationId) || 
              isEscalationCreator(escalationId) ||
              isAssignedResponder(escalationId));
    }
    
    function canResolveIncident(escalationId) {
      return request.auth != null && 
             (isCurrentOwner(escalationId) || isEscalationCreator(escalationId));
    }
    
    function isValidSeverity() {
      return request.resource.data.severity in ['critical', 'high', 'medium', 'low'];
    }
    
    function isValidEscalationStatus() {
      return request.resource.data.status in ['open', 'escalated', 'in_progress', 'awaiting_response', 'on_hold', 'resolved', 'archived', 'cancelled'];
    }
    
    function isValidLevel() {
      return request.resource.data.currentLevel in ['individual', 'family', 'community', 'professional'];
    }
    
    // Escalations collection - Phase 3
    match /escalations/{escalationId} {
      // CREATE: Authenticated users can create escalations
      allow create: if request.auth != null &&
                       request.resource.data.createdBy == request.auth.uid &&
                       isValidSeverity() &&
                       isValidEscalationStatus() &&
                       isValidLevel();
      
      // READ: Allow all authenticated users to read escalations (simplified for development)
      allow read: if request.auth != null;
      
      // UPDATE: Current owner or escalation creator can update
      allow update: if request.auth != null &&
                       canEscalateIncident(escalationId) &&
                       isValidEscalationStatus();
      
      // DELETE: Never allow deletion (audit trail requirement)
      allow delete: if false;
      
      // Responder assignments subcollection
      match /responders/{responderId} {
        // CREATE: Current owner or escalation creator can assign
        allow create: if request.auth != null &&
                         canEscalateIncident(escalationId) &&
                         request.resource.data.escalationId == escalationId &&
                         request.resource.data.assignedBy == request.auth.uid;
        
        // READ: Assigned responder, current owner, or creator
        allow read: if request.auth != null &&
                       (request.auth.uid == resource.data.userId ||
                        isCurrentOwner(escalationId) ||
                        isEscalationCreator(escalationId));
        
        // UPDATE: Assigned responder can update their own status
        allow update: if request.auth != null &&
                         request.auth.uid == resource.data.userId;
        
        // DELETE: Never allow
        allow delete: if false;
        
        // Actions subcollection - Track what responder did
        match /actions/{actionId} {
          // CREATE: Assigned responder can log actions
          allow create: if request.auth != null &&
                           request.auth.uid == get(/databases/$(database)/documents/escalations/$(escalationId)/responders/$(responderId)).data.userId &&
                           request.resource.data.takenBy == request.auth.uid;
          
          // READ: Same access as responder
          allow read: if request.auth != null &&
                         (request.auth.uid == get(/databases/$(database)/documents/escalations/$(escalationId)/responders/$(responderId)).data.userId ||
                          isCurrentOwner(escalationId) ||
                          isEscalationCreator(escalationId));
          
          // WRITE: Never allow updates to actions (immutable audit trail)
          allow write: if false;
        }
      }
      
      // Audit trail subcollection - Immutable, server-written only
      match /audit_trail/{auditId} {
        // READ: Creator, owner, or assigned responders
        allow read: if request.auth != null &&
                       (isEscalationCreator(escalationId) ||
                        isCurrentOwner(escalationId) ||
                        isAssignedResponder(escalationId));
        
        // WRITE: Server-side only
        allow write: if false;
      }
    }
    
    // Incident metrics collection (server-write, read-only for users)
    match /incident_metrics/{metricsId} {
      // READ: Authenticated users can read metrics
      allow read: if request.auth != null;
      
      // WRITE: Server-side only
      allow write: if false;
    }
    
    // Responder performance collection (server-write, read-only)
    match /responder_performance/{performanceId} {
      // READ: Responders can read their own, admins can read all
      allow read: if request.auth != null;
      
      // WRITE: Server-side only
      allow write: if false;
    }
    
    // Escalation rules collection (read-only, system-managed)
    match /escalation_rules/{ruleId} {
      // READ: Authenticated users
      allow read: if request.auth != null;
      
      // WRITE: Never allow direct writes
      allow write: if false;
    }
    
    // ========================================
    // PHASE 6: Mobile Integration Collections
    // ========================================
    
    // Bridge devices - for web-to-mobile sync
    match /bridge_devices/{deviceId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && 
                   (request.resource.data.userId == request.auth.uid || 
                    resource.data.userId == request.auth.uid);
    }
    
    // Bridge messages - real-time signaling
    match /bridge_messages/{messageId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Mesh network peers - WebRTC connections
    match /mesh_peers/{peerId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Mesh network signals - temporary WebRTC signaling
    match /mesh_signals/{signalId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
      allow delete: if request.auth != null;
    }
    
    // ========================================
    // PHASE 6: Collaboration Collections
    // ========================================
    
    // Comments - for incidents, projects, etc.
    match /comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && 
                    request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && 
                    (resource.data.userId == request.auth.uid || 
                     request.resource.data.reactions != null);
      allow delete: if request.auth != null && 
                    resource.data.userId == request.auth.uid;
    }
    
    // Activity feed - real-time activity stream
    match /activity_feed/{activityId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // User presence tracking
    match /presence/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && userId == request.auth.uid;
    }

    // Event reminders - user-scoped reminders for calendar events
    match /reminders/{reminderId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
      
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // ========================================================================
    // NOTIFICATIONS COLLECTION - SPRINT 4B Notifications Hub
    // ========================================================================
    
    // Notifications collection - User-scoped CRUD with automatic cleanup
    match /notifications/{notificationId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow create: if request.auth != null;
      allow update: if request.auth != null && resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Notification Preferences collection - Users manage their own preferences
    match /notificationPreferences/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // ========================================================================
    // ANALYTICS COLLECTIONS - SPRINT 4C Analytics Dashboard
    // ========================================================================
    
    // Analytics data - Read by owner, write restricted
    match /analytics/{familyId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null;
      allow delete: if false; // Preserve analytics history
    }

    // Analytics cache - Temporary data for performance
    match /analyticsCache/{cacheId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }

    // Insights - User-scoped insights
    match /insights/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // ========================================================================
    // COLLABORATION COLLECTIONS - SPRINT 4D Collaborative Features
    // ========================================================================

    // Comments subcollection under events
    match /events/{eventId}/comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Presence tracking subcollection under events
    match /events/{eventId}/presence/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Permissions subcollection under events
    match /events/{eventId}/permissions/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        exists(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)).data.role in ['owner', 'manager']
      );
    }

    // Activity log subcollection under events
    match /events/{eventId}/activityLog/{logId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if false;
    }

    // Shared documents subcollection under events
    match /events/{eventId}/documents/{docId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.uploadedBy == request.auth.uid;
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.uploadedBy ||
        exists(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)).data.role in ['owner', 'manager']
      );
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.uploadedBy ||
        exists(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/events/$(eventId)/permissions/$(request.auth.uid)).data.role in ['owner', 'manager']
      );
    }

    // ========================================================================
    // DUAL CALENDAR SYSTEM COLLECTIONS - PHASE 1B
    // ========================================================================
    
    // Calendar Systems - Read by all authenticated, write by admins only
    match /calendarSystems/{calendarSystemId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com',
        'kwakhomdeni@gmail.com'
      ];
      allow delete: if false; // Never allow deletion of calendar systems
    }
    
    // Calendar Overlays - Users can manage their own event overlays
    match /calendarOverlays/{overlayId} {
      allow read: if request.auth != null && (
        resource.data.eventId in get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.attendees ||
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.organizer == request.auth.uid
      );
      allow create: if request.auth != null && 
                       exists(/databases/$(database)/documents/events/$(request.resource.data.eventId));
      allow update: if request.auth != null && (
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.organizer == request.auth.uid
      );
      allow delete: if request.auth != null && (
        get(/databases/$(database)/documents/events/$(resource.data.eventId)).data.organizer == request.auth.uid
      );
    }
    
    // Seasonal Markers - Read by all authenticated, write by admins only
    match /seasonalMarkers/{markerId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null && request.auth.token.email in [
        'spiceinc@gmail.com',
        'zenzxru@gmail.com',
        'kwakhomdeni@gmail.com'
      ];
      allow delete: if false; // Never allow deletion of seasonal markers
    }

    // Default: deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}